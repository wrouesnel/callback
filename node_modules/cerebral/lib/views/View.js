'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DependencyTracker = require('../DependencyTracker');

var _DependencyTracker2 = _interopRequireDefault(_DependencyTracker);

var _Compute = require('../Compute');

var _utils = require('./../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var View = function () {
  function View(_ref) {
    var _this = this;

    var dependencies = _ref.dependencies,
        mergeProps = _ref.mergeProps,
        props = _ref.props,
        controller = _ref.controller,
        displayName = _ref.displayName,
        onUpdate = _ref.onUpdate;

    _classCallCheck(this, View);

    this.stateGetter = this.stateGetter.bind(this);
    this.signalGetter = this.signalGetter.bind(this);
    this.mergeProps = mergeProps;
    this.controller = controller;
    this._displayName = displayName;
    this._hasWarnedBigComponent = false;
    this.onUpdate = onUpdate;

    if (this.controller.devtools) {
      this.verifyProps(props);
    }

    /*
      First we find any dependency functions to convert to DependencyTrackers.
      They are instantly run to produce their value and map of state
      dependencies
    */
    this.dependencyTrackers = Object.keys(dependencies).reduce(function (currentDependencyTrackers, dependencyKey) {
      if (dependencies[dependencyKey] instanceof _Compute.Compute) {
        currentDependencyTrackers[dependencyKey] = new _DependencyTracker2.default(dependencies[dependencyKey]);
        currentDependencyTrackers[dependencyKey].run(_this.stateGetter, props);
      }

      return currentDependencyTrackers;
    }, {});
    this.dependencies = dependencies;
    this.dependencyTrackersDependencyMaps = this.getDependencyTrackersDependencyMaps(props);
    this.tagsDependencyMap = this.getTagsDependencyMap(props);
  }
  /*
    A method to ensure objects and arrays from state tree are not passed as props
  */


  _createClass(View, [{
    key: 'verifyProps',
    value: function verifyProps(props) {
      var key = (0, _utils.getStateTreeProp)(props);
      if (key) {
        console.warn('You are passing an ' + (Array.isArray(props[key]) ? 'array' : 'object') + ' to the component "' + this._displayName + '" on prop "' + key + '" which is from the Cerebral state tree. You should not do this, but rather connect it directly to this component. This will optimize the component and avoid any rerender issues.');
      }
    }
    /*
      A getter for StateTracker and tags to grab state from Cerebral
    */

  }, {
    key: 'stateGetter',
    value: function stateGetter(path) {
      return this.controller.getState(path);
    }
    /*
      A getter for tags to grab signals from Cerebral
    */

  }, {
    key: 'signalGetter',
    value: function signalGetter(path) {
      return this.controller.getSignal(path);
    }
  }, {
    key: 'onMount',
    value: function onMount() {
      var depsMap = Object.assign({}, this.dependencyTrackersDependencyMaps.state, this.tagsDependencyMap);

      this.controller.componentDependencyStore.addEntity(this, depsMap);

      if (this.controller.devtools) {
        this.controller.devtools.updateComponentsMap(this, depsMap);
      }
    }
  }, {
    key: 'onUnMount',
    value: function onUnMount() {
      var depsMap = Object.assign({}, this.dependencyTrackersDependencyMaps.state, this.tagsDependencyMap);
      this.controller.componentDependencyStore.removeEntity(this, depsMap);

      if (this.controller.devtools) {
        this.controller.devtools.updateComponentsMap(this, null, depsMap);
      }
    }
  }, {
    key: 'onPropsUpdate',
    value: function onPropsUpdate(props, nextProps) {
      if (this.controller.devtools) {
        this.verifyProps(nextProps);
      }

      var propsChanges = (0, _utils.getChangedProps)(props, nextProps);
      if (propsChanges.length) {
        this.updateFromProps(propsChanges, nextProps);

        return true;
      }

      return false;
    }
    /*
      Called by component when props are passed from parent and they
      have changed. In this situation both tags and depndency trackers might
      be affected. Tags are just updated and dependency trackers are matched
      on props changed
    */

  }, {
    key: 'updateFromProps',
    value: function updateFromProps(propsChanges, props) {
      this.update(props, this.updateDependencyTrackers({}, propsChanges, props));
    }
    /*
      Called by Container when the components state dependencies
      has changed. In this scenario we need to run any dependencyTrackers
      that matches the state changes. There is no need to update the tags
      as their declared state deps can not change
    */

  }, {
    key: 'updateFromState',
    value: function updateFromState(stateChanges, props, force) {
      this.update(props, force ? this.forceUpdateDependencyTrackers() : this.updateDependencyTrackers(stateChanges, {}, props));
    }
    /*
      Udpates the dependency trackers by checking state
      changes and props changes
    */

  }, {
    key: 'updateDependencyTrackers',
    value: function updateDependencyTrackers(stateChanges, propsChanges, props) {
      var _this2 = this;

      var hasChanged = Object.keys(this.dependencyTrackers).reduce(function (hasChanged, key) {
        if (_this2.dependencyTrackers[key].match(stateChanges, propsChanges)) {
          _this2.dependencyTrackers[key].run(_this2.stateGetter, props);

          return true;
        }

        return hasChanged;
      }, false);

      return hasChanged;
    }
    /*
      Run update, re-evaluating the tags and computed, if neccessary
    */

  }, {
    key: 'update',
    value: function update(props, hasChangedDependencyTrackers) {
      var prevDependencyTrackersDependencyMaps = this.dependencyTrackersDependencyMaps;
      var previousTagsDependencyMap = this.tagsDependencyMap;

      this.tagsDependencyMap = this.getTagsDependencyMap(props);
      this.dependencyTrackersDependencyMaps = hasChangedDependencyTrackers ? this.getDependencyTrackersDependencyMaps(props) : this.dependencyTrackersDependencyMaps;

      var prevDepsMap = Object.assign({}, prevDependencyTrackersDependencyMaps.state, previousTagsDependencyMap);
      var nextDepsMap = Object.assign({}, this.dependencyTrackersDependencyMaps.state, this.tagsDependencyMap);
      this.controller.componentDependencyStore.updateEntity(this, prevDepsMap, nextDepsMap);

      if (this.controller.devtools) {
        this.controller.devtools.updateComponentsMap(this, nextDepsMap, prevDepsMap);
      }
    }
    /*
      Forces update of all computed
    */

  }, {
    key: 'forceUpdateDependencyTrackers',
    value: function forceUpdateDependencyTrackers() {
      var _this3 = this;

      Object.keys(this.dependencyTrackers).forEach(function (key) {
        _this3.dependencyTrackers[key].run(_this3.stateGetter, _this3.props);
      });

      return true;
    }
    /*
      Go through dependencies and identify state trackers and
      merge in their state dependencies
    */

  }, {
    key: 'getDependencyTrackersDependencyMaps',
    value: function getDependencyTrackersDependencyMaps(props) {
      var _this4 = this;

      return Object.keys(this.dependencies).reduce(function (currentDepsMaps, propKey) {
        if (_this4.dependencyTrackers[propKey]) {
          currentDepsMaps.state = Object.assign(currentDepsMaps.state, _this4.dependencyTrackers[propKey].stateTrackFlatMap);
          currentDepsMaps.props = Object.assign(currentDepsMaps.props, _this4.dependencyTrackers[propKey].propsTrackFlatMap);

          return currentDepsMaps;
        }

        return currentDepsMaps;
      }, {
        state: {},
        props: {}
      });
    }
    /*
      Go through dependencies and extract tags related to state
      dependencies
    */

  }, {
    key: 'getTagsDependencyMap',
    value: function getTagsDependencyMap(props) {
      var _this5 = this;

      return Object.keys(this.dependencies).reduce(function (currentDepsMap, propKey) {
        if (_this5.dependencyTrackers[propKey]) {
          return currentDepsMap;
        }

        if (!_this5.dependencies[propKey].getTags) {
          (0, _utils.throwError)('Prop ' + propKey + ' should be tags or a function on the specific property you want to dynamically create.');
        }

        var getters = _this5.createTagGetters(props);

        return _this5.dependencies[propKey].getTags(getters).reduce(function (updatedCurrentDepsMap, tag) {
          if (tag.options.isStateDependency) {
            var path = tag.getPath(getters);
            var strictPath = (0, _utils.ensureStrictPath)(path, _this5.stateGetter(path));

            updatedCurrentDepsMap[strictPath] = true;
          }

          return updatedCurrentDepsMap;
        }, currentDepsMap);
      }, {});
    }
    /*
      Creates getters passed into tags
    */

  }, {
    key: 'createTagGetters',
    value: function createTagGetters(props) {
      return {
        state: this.stateGetter,
        props: props,
        signal: this.signalGetter
      };
    }
    /*
      Runs whenever the component has an update and renders.
      Extracts the actual values from dependency trackers and/or tags
    */

  }, {
    key: 'getProps',
    value: function getProps() {
      var _this6 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var dependenciesProps = Object.keys(this.dependencies).reduce(function (currentProps, key) {
        if (!_this6.dependencies[key]) {
          (0, _utils.throwError)('There is no dependency assigned to prop ' + key);
        }

        if (_this6.dependencyTrackers[key]) {
          currentProps[key] = _this6.dependencyTrackers[key].value;
        } else {
          var tag = _this6.dependencies[key];
          var getters = _this6.createTagGetters(props);

          if (tag.type === 'state') {
            var path = tag.getPath(getters);
            var value = _this6.stateGetter(path);

            if (path.indexOf('.*') > 0) {
              currentProps[key] = value ? Object.keys(value) : [];
            } else {
              currentProps[key] = value;
            }
          } else if (tag.type === 'signal') {
            try {
              currentProps[key] = tag.getValue(getters);
            } catch (e) {
              var _path = tag.getPath(getters);
              (0, _utils.throwError)('Component ' + _this6._displayName + ' There is no signal at \'' + _path + '\'');
            }
          } else if (tag.type === 'props') {
            currentProps[key] = tag.getValue(getters);
          }
        }

        return currentProps;
      }, {});

      if (this.controller.devtools && this.controller.devtools.bigComponentsWarning && !this._hasWarnedBigComponent && Object.keys(this.dependencies).length >= this.controller.devtools.bigComponentsWarning) {
        console.warn('Component named ' + this._displayName + ' has a lot of dependencies, consider refactoring or adjust this option in devtools');
        this._hasWarnedBigComponent = true;
      }

      if (this.mergeProps) {
        return this.mergeProps(dependenciesProps, props, (0, _utils.createResolver)(this.createTagGetters(props)));
      }

      return Object.assign({}, props, dependenciesProps);
    }
  }]);

  return View;
}();

exports.default = View;
//# sourceMappingURL=View.js.map