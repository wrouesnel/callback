'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Devtools = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

exports.default = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return new (Function.prototype.bind.apply(Devtools, [null].concat(args)))();
};

var _utils = require('../utils');

var _base = require('function-tree/lib/devtools/base');

var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global WebSocket File FileList Blob ImageData VERSION */


var PLACEHOLDER_INITIAL_MODEL = 'PLACEHOLDER_INITIAL_MODEL';
var PLACEHOLDER_DEBUGGING_DATA = '$$DEBUGGING_DATA$$';

/*
  Connects to the Cerebral debugger
  - Triggers events with information from function tree execution
  - Stores data related to time travel, if activated
*/

var Devtools = exports.Devtools = function (_DevtoolsBase) {
  _inherits(Devtools, _DevtoolsBase);

  function Devtools() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$storeMutations = _ref.storeMutations,
        storeMutations = _ref$storeMutations === undefined ? true : _ref$storeMutations,
        _ref$preventExternalM = _ref.preventExternalMutations,
        preventExternalMutations = _ref$preventExternalM === undefined ? true : _ref$preventExternalM,
        _ref$preventPropsRepl = _ref.preventPropsReplacement,
        preventPropsReplacement = _ref$preventPropsRepl === undefined ? false : _ref$preventPropsRepl,
        _ref$bigComponentsWar = _ref.bigComponentsWarning,
        bigComponentsWarning = _ref$bigComponentsWar === undefined ? 10 : _ref$bigComponentsWar,
        _ref$remoteDebugger = _ref.remoteDebugger,
        remoteDebugger = _ref$remoteDebugger === undefined ? null : _ref$remoteDebugger,
        _ref$host = _ref.host,
        host = _ref$host === undefined ? null : _ref$host,
        _ref$reconnect = _ref.reconnect,
        reconnect = _ref$reconnect === undefined ? true : _ref$reconnect,
        _ref$reconnectInterva = _ref.reconnectInterval,
        reconnectInterval = _ref$reconnectInterva === undefined ? 5000 : _ref$reconnectInterva,
        _ref$allowedTypes = _ref.allowedTypes,
        allowedTypes = _ref$allowedTypes === undefined ? [] : _ref$allowedTypes;

    _classCallCheck(this, Devtools);

    var _this = _possibleConstructorReturn(this, (Devtools.__proto__ || Object.getPrototypeOf(Devtools)).call(this, {
      remoteDebugger: remoteDebugger,
      host: host,
      reconnect: reconnect,
      reconnectInterval: reconnectInterval
    }));

    _this.version = "2.0.0-beta.3";
    _this.debuggerComponentsMap = {};
    _this.debuggerComponentDetailsId = 1;
    _this.storeMutations = storeMutations;
    _this.preventExternalMutations = preventExternalMutations;
    _this.preventPropsReplacement = preventPropsReplacement;
    _this.bigComponentsWarning = bigComponentsWarning;

    _this.mutations = [];
    _this.initialModelString = null;
    _this.controller = null;
    _this.originalRunTreeFunction = null;
    _this.isResettingDebugger = false;
    _this.allowedTypes = [].concat(typeof File === 'undefined' ? [] : File).concat(typeof FileList === 'undefined' ? [] : FileList).concat(typeof Blob === 'undefined' ? [] : Blob).concat(typeof ImageData === 'undefined' ? [] : ImageData).concat(typeof RegExp === 'undefined' ? [] : RegExp).concat(allowedTypes || []);

    _this.sendInitial = _this.sendInitial.bind(_this);
    _this.sendComponentsMap = (0, _utils.delay)(_this.sendComponentsMap, 50);
    return _this;
  }
  /*
    To remember state Cerebral stores the initial model as stringified
    object. Since the model is mutable this is necessary. The debugger
    passes the execution id of the signal that was double clicked. This
    execution id is searched backwards in the array of mutations done.
    This is necessary as multiple mutations can be done on the same execution.
    Then all mutations are replayed to the model and all the components
    will be rerendered using the "flush" event and "force" flag.
     It will also replace the "run" method of the controller to
    prevent any new signals firing off when in "remember state"
  */


  _createClass(Devtools, [{
    key: 'remember',
    value: function remember(index) {
      this.controller.model.set([], JSON.parse(this.initialModelString));

      if (index === 0) {
        this.controller.run = this.originalRunTreeFunction;
      } else {
        this.controller.run = function (name) {
          console.warn('The signal "' + name + '" fired while debugger is remembering state, it was ignored');
        };
      }

      for (var x = 0; x < this.mutations.length - index; x++) {
        var _controller$model;

        var mutation = JSON.parse(this.mutations[x].data);
        (_controller$model = this.controller.model)[mutation.method].apply(_controller$model, _toConsumableArray(mutation.args));
      }

      this.controller.flush(true);
      this.controller.emit('remember', JSON.parse(this.mutations[index].data).datetime);
    }
    /*
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.controller.model.set([], JSON.parse(this.initialModelString));
      this.backlog = [];
      this.mutations = [];
      this.controller.flush(true);
    }
  }, {
    key: 'createSocket',
    value: function createSocket() {
      this.ws = new WebSocket('ws://' + this.host);
    }
  }, {
    key: 'onMessage',
    value: function onMessage(event) {
      var message = JSON.parse(event.data);
      switch (message.type) {
        case 'changeModel':
          this.controller.model.set(message.data.path, message.data.value);
          this.controller.flush();
          break;
        case 'remember':
          if (!this.storeMutations) {
            console.warn('Cerebral Devtools - You tried to time travel, but you have turned of storing of mutations');
          } else {
            this.remember(message.data);
          }
          break;
        case 'reset':
          this.reset();
          break;
        case 'pong':
          this.sendInitial();
          break;
        case 'ping':
          this.sendInitial();
          break;
      }
    }
    /*
      The debugger might be ready or it might not. The initial communication
      with the debugger requires a "ping" -> "pong" to identify that it
      is ready to receive messages.
      1. Debugger is open when app loads
        - Devtools sends "ping"
        - Debugger sends "pong"
        - Devtools sends "init"
      2. Debugger is opened after app load
        - Debugger sends "ping"
        - Devtools sends "init"
    */

  }, {
    key: 'init',
    value: function init(controller) {
      this.controller = controller || this.controller;
      this.originalRunTreeFunction = this.controller.run;

      if (this.storeMutations) {
        this.initialModelString = JSON.stringify(this.controller.model.get());
      }

      _get(Devtools.prototype.__proto__ || Object.getPrototypeOf(Devtools.prototype), 'init', this).call(this);

      if (controller) {
        this.watchExecution(this.controller, 'c');
      }
    }
    /*
      Send initial model. If model has already been stringified we reuse it. Any
      backlogged executions will also be triggered
    */

  }, {
    key: 'sendInitial',
    value: function sendInitial() {
      var initialModel = this.controller.model.get();
      var message = JSON.stringify({
        type: 'init',
        source: 'c',
        version: this.version,
        data: {
          initialModel: this.initialModelString ? PLACEHOLDER_INITIAL_MODEL : initialModel
        }
      }).replace('"' + PLACEHOLDER_INITIAL_MODEL + '"', this.initialModelString);

      this.isResettingDebugger = true;
      this.sendMessage(message);
      if (this.backlog.length) {
        this.sendBulkMessage(this.backlog, 'c');
        this.backlog = [];
      }
      this.isResettingDebugger = false;

      this.isConnected = true;

      this.sendMessage(JSON.stringify({
        type: 'components',
        source: 'c',
        version: this.version,
        data: {
          map: this.debuggerComponentsMap,
          render: {
            components: []
          }
        }
      }));
    }
    /*
      Create the stringified message for the debugger. As we need to
      store mutations with the default true "storeMutations" option used
      by time travel and jumping between Cerebral apps, we are careful
      not doing unnecessary stringifying.
    */

  }, {
    key: 'createExecutionMessage',
    value: function createExecutionMessage(debuggingData, context, functionDetails, payload) {
      var type = 'execution';
      var mutationString = '';

      if (this.storeMutations && debuggingData && debuggingData.type === 'mutation') {
        mutationString = JSON.stringify(debuggingData);
      }

      var data = {
        execution: {
          executionId: context.execution.id,
          functionIndex: functionDetails.functionIndex,
          payload: payload,
          datetime: context.execution.datetime,
          data: mutationString ? PLACEHOLDER_DEBUGGING_DATA : debuggingData
        }
      };

      if (mutationString) {
        this.mutations.push({
          executionId: context.execution.id,
          data: mutationString
        });
      }

      return JSON.stringify({
        type: type,
        source: 'c',
        version: this.version,
        data: data
      }).replace('"' + PLACEHOLDER_DEBUGGING_DATA + '"', mutationString);
    }
    /*
      The container will listen to "flush" events from the controller
      and send an event to debugger about initial registered components
    */

  }, {
    key: 'extractComponentName',
    value: function extractComponentName(component) {
      return component._displayName.replace('CerebralWrapping_', '');
    }
    /*
      Updates the map the represents what active state paths and
      components are in your app.Called from Controller. Used by the debugger
    */

  }, {
    key: 'updateComponentsMap',
    value: function updateComponentsMap(component, nextDeps, prevDeps) {
      var componentDetails = {
        name: this.extractComponentName(component),
        renderCount: component.renderCount || 0,
        id: component.componentDetailsId || this.debuggerComponentDetailsId++
      };

      if (arguments.length === 1) {
        componentDetails.renderCount++;
      }

      component.componentDetailsId = componentDetails.id;
      component.renderCount = componentDetails.renderCount;

      if (prevDeps) {
        for (var depsKey in prevDeps) {
          var debuggerComponents = this.debuggerComponentsMap[depsKey];

          for (var x = 0; x < debuggerComponents.length; x++) {
            if (debuggerComponents[x].id === component.componentDetailsId) {
              debuggerComponents.splice(x, 1);
              if (debuggerComponents.length === 0) {
                delete this.debuggerComponentsMap[depsKey];
              }
              break;
            }
          }
        }
      }

      if (nextDeps) {
        for (var _depsKey in nextDeps) {
          this.debuggerComponentsMap[_depsKey] = this.debuggerComponentsMap[_depsKey] ? this.debuggerComponentsMap[_depsKey].concat(componentDetails) : [componentDetails];
        }
      }
    }
    /*
      Sends components map to debugger. It is debounced (check constructor).
      It needs to wait because React updates async. Instead of tracking
      callbacks we just wait 50ms as it is not that important when
      debugger updates
    */

  }, {
    key: 'sendComponentsMap',
    value: function sendComponentsMap(componentsToRender, changes, start, end) {
      if (this.isConnected) {
        this.sendMessage(JSON.stringify({
          type: 'components',
          source: 'c',
          version: this.version,
          data: {
            map: this.debuggerComponentsMap,
            render: {
              start: start,
              duration: end - start,
              changes: changes,
              components: componentsToRender.map(this.extractComponentName)
            }
          }
        }));
      }
    }
  }]);

  return Devtools;
}(_base2.default);
//# sourceMappingURL=index.js.map